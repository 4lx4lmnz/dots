#!/bin/bash

# Do completion from a passed list of paths
#
# Accepts 2 arguments
# 1. The list of paths to complete from
# 2. The current word being completed
__dots_path_comp()
{
	# This forces readline to only display the last item separated by a slash
	compopt -o filenames

	local IFS=$'\n'
	local k="${#COMPREPLY[@]}"

	for path in $(compgen -W "$1" -- $2)
	do
		local trailing_trim

		# Determine what to trim from the end
		trailing_trim="${path#${2%/*}/}/"
		trailing_trim="${trailing_trim#*/}"
		trailing_trim="${trailing_trim%/}"

		# Don't add a space if there is more to complete
		[[ "$trailing_trim" != "" ]] && compopt -o nospace

		COMPREPLY[k++]="${path%%${trailing_trim}}"
	done
}

_dots_completions()
{
	local base_cmds=(groups diff files install help)
	local base_flags=(-c --config)

	local cur=${COMP_WORDS[$COMP_CWORD]}
	local prev=${COMP_WORDS[$COMP_CWORD-1]}

	# Determine the command position
	local cmd_index=1
	[[ ${COMP_WORDS[1]} =~ -c|--config ]] && cmd_index=3

	# Include additional flags for the first word
	if [[ $COMP_CWORD == 1 ]]
	then
		COMPREPLY=( $(compgen -W "${base_cmds[*]} ${base_flags[*]}" -- $cur) )
		return
	fi

	# Perform file completion for the config option
	if [[ $cmd_index > $COMP_CWORD ]]
	then
		compopt -o default
		return
	fi

	# Perform completion on the base command
	if [[ $COMP_CWORD == $cmd_index ]]
	then
		COMPREPLY=( $(compgen -W "${base_cmds[*]}" -- $cur) )
		return
	fi

	# Perform completion for sub-commands
	case "${COMP_WORDS[$cmd_index]}" in
		groups)
			COMPREPLY=()
			;;
		diff)
			COMPREPLY=()
			;;
		files)
			__dots_path_comp "$(dots files)" $cur
			;;
		install)
			COMPREPLY=()
			;;
	esac
}

complete -F _dots_completions dots
