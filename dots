#!/bin/bash

set -e

# Use default Free desktop specification if this isn't defined
XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-$HOME/.config}"

# Get the path to the dot-configuration repository. The root is the location of
# this bash script. Must resolve the symlink
config_root="${BASH_SOURCE[0]}"

while [ -h "$config_root" ]
do
	config_root="$(readlink "$config_root")"
done;

config_root="$(dirname "$config_root")"
config_root="$(cd "$config_root" && pwd)"

# This is the file that the current groups configuration is stored in
groups_file="$config_root/.groups"

# error [message]
#
# Exit the script and print a error
#
# message: The message to print to stderr just before exiting
function error()
{
	echo -e "Error: $1" 1>&2
	exit 1
}

# list-groups
#
# Echos a list of all available configuration groups that can be enabled. All
# directories aside from the base directory are expected to contain groups.
function list-groups()
{
	# The base group is an implicit group
	echo "base"

	# All other groups are nested under directories
	find "$config_root" -maxdepth 2 -mindepth 2 \
		-not -path "$config_root/.git/*" \
		-not -path "$config_root/base/*" \
		-type d -printf '%P\n'
}

# set-groups
#
# Set the list of configuration groups that should be used to compile the
# configuration tree upon calling `install`. These valeus are stored in the
# $groups_file
#
# args: Each argument represents a group to be stored in the groups_file
function set-groups()
{
	# Only set the groups if they aren't already set
	[[ -e "$groups_file" ]] && error "Groups already set, use clear-groups first"
	[[ $# == 0 ]] && error "No groups specified"

	local groups="$(IFS=$'\n'; echo "$*")"

	# Find any config groups that aren't available
	local invalid_groups="$(echo "$groups" | grep \
		--invert-match  \
		--fixed-strings \
		--line-regexp "$(list-groups)" | tr "\n" " ")"

	# Error out if any groups aren't valid
	[[ -n "$invalid_groups" ]] && error "Invalid groups: ${invalid_groups}"

	# Save the groups configuration
	echo "$groups" > "$groups_file"
}

# clear-groups
#
# Removes the $groups_file
function clear-groups()
{
	rm "$groups_file"
}

# build-tree [build-path] [groups]
#
# This function will create the entirely pre-processed file tree containing all
# configuration files required for the specified configuration groups.
#
# groups:     A list of configuration groups that should be used to
# build_path: This should be a directory path where the configuration files
#             should be compiled into. If the directory doesn't exit it will
#             be created. If the string is null a temp directory will be created
function build-tree()
{
	[[ $# < 1 ]] && error "Invalid ammount of agruments"

	local groups=($1)
	local build_path="$2"

	# Create a temporary directory if the build_path is null
	if [ -z "$build_path" ]
	then
		build_path="$(mktemp -d)"
	fi

	# Handle each configuration groups tree
	for group in "${groups[@]}"
	do
		# Pass each file to be installed to compile-tree
		find "$config_root/$group" -type f -printf "%P\0" \
			| while read -d $'\0' file
		do
			compile-tree "${group%/}" "$file" "$build_path"
		done
	done
	exit 1
}


function compile-tree()
{
	[[ $# != 3 ]] && error "Invalid ammount of arguments"

	local config_group="$1"
	local source_file="$2"
	local build_path="$3"

	echo "Installing $source_file from group \"$config_group\" into $build_path"
}

build-tree "$(cat "$groups_file")"
