#!/bin/env python2.7
#
# dots - A cascading dot file management tool
#
# The dots utility is used to manage a grouping of dotfiles for various
# environments and UNIX like platforms. The primary goal of this utility it to
# facilitate the logical separation of dotfiles and providing the ability to
# 'compile' this organization into a usable directory tree of files.
#
# DIRECTORY STRUCTURE AND GROUPINGS
#
# By default configuration files should be stored two subdirectories deep from
# the location where this script is located. For example `machines/desktop/`
# could be used to store configuration files specific to a users desktop
# machine. The exception to this is the `base` group, which is only one
# directory deep.
#
# You may have as many configuration groupings as you would like.
#
# CASCADING OF CONFIGURATION FILES
#
# If two groups are specified for a configuration environment that both contain
# the same configuration file, then the file will 'cascade'. What this means is
# that the file in the second group will be appended to the first group.
#
# OVERRIDING AND EXTENDING
#
# The cascading logic can be modified by 'overriding' or 'extending' a file.
#
# Overriding a file allows you to force configuration files that exist earlier
# in the configuration environment groups list to be discarded instead of being
# used as the base for a configuration file to be appended to. For example:
#
#    base/bash/bashrc
#    machines/desktop/bash/bashrc.override
#
#    groups = ['base', 'machines/desktop']
#
# Instead of the machines/desktop version of the bashrc file being amended to
# the base bashrc file, it will simply discard the base version of the file.
#
# Extending a file allows you to specify 'explicit append points' in a file.
# This way instead of having a cascading file be appended to the end, it could
# be appended somewhere else. Continuing from the last example (without the
# .override):
#
# If the `base/bash/bashrc` file contains the symbol `!!@@' in the file, this is
# where the `machines/desktop/bash/bashrc` file would be appended.
#
# You may also use 'named append points'. This allows you to insert 'fragment'
# files into a file. For example, say we have the following files:
#
#    base/bash/bashrc
#    base/bash/bashrc.aliases
#
# If somewhere within the `base/bash/bashrc` file we have the symbol
# '!!@@aliases' then the `bashrc.aliases` file would be appended at.
#
# Fragment files are subject to all of the same logic described above
# (extending, append points, and even named append points)
#
# PROGRAM USAGE
#
# See USAGE variable

import sys, os, shutil, subprocess
import glob
import re
import tempfile
import argparse

USAGE="""dots - A dot file pre-processor and installer

dots [-c CONFIG] COMMAND [options]

The following commands and options are available:

-c       Specify the file to load and save configuration environment groups
         lists to. If not specified the default configuration file will be used

groups   Manage available configuration groups

         list     List all configuration groups that are available to be
                  specified for a configuration environment list

         current  Get the current configuration environment groups

         set      Specify a space separated list of valid configuration groups
                  to enable for this environment

diff     Get the difference between the source files, and currently installed
         configuration files

         [FILES]  A list of one or more files to check. If this is omitted
                  then the entire tree of source configuration files will be
                  diffed

install  Compile and install one or more configuration files into a location.
         If no specific files are specified then the entire source tree will
         be installed into the specified location and after-install scripts
         will be executed

         [FILES]  A list of one or more files to install into the specified
                  location. If omitted the entire tree will be installed

         -l       Specify the location to install the configuration files to.
                  If omitted the default XDG_CONFIG_HOME path will be used

         -i       Confirm with a diff before overwriting already existing
                  configuration files in the install location

help     This help message"""

# Locate the configuration directory that all source configuration files are
# stored in. This _should_ be the same directory that this script is located in
SOURCE_DIR = os.path.dirname(os.path.realpath(__file__))
os.chdir(SOURCE_DIR)

# Get the location that we will be installing all of the files into
INSTALL_DIR = os.getenv('XDG_CONFIG_HOME', os.path.join(os.environ['HOME'], '/.config'))

# The named append point identifier in files
AP_IDENTIFIER = '!!@@'

# The file extension used to identify 'overriding' files
OVERRIDE_EXT = '.override'

# The command to use to diff with git
GIT_DIFF = ['git', 'diff', '--diff-filter=MA', '--']

class Configuration(object):

	# This is a list of groups that are only a single directory deep and do not
	# contain any groups in sub-directories. The directories in these folders
	# will be the directories that are installed as configuration files
	single_directory_groups = ['base'];

	# Determine which groups are valid by looking at the directory structure of
	# that the script is installed in. Groups not defined in the
	# single_directory_groups array will be considered nested groups
	valid_groups = [g for g in glob.glob('*/*') if not
			g.startswith(tuple(single_directory_groups))] + \
			single_directory_groups

	# This is the default groups file that the configuration group listing for
	# the machine should be stored in
	default_group_file = os.path.join(os.getenv('XDG_CACHE_HOME',
		os.path.join(os.environ['HOME'], '.cache')), 'config-group')

	def __init__(self, group_file=default_group_file, groups=[]):
		self.group_file = group_file
		self.groups = groups

	@property
	def groups(self):
		"""Return the list of groups configured for this system"""
		return self._groups

	@groups.setter
	def groups(self, groups):
		"""Set the list of groups for this configuration"""
		# Trim trailing and leading slashes
		groups = [x.strip('/') for x in groups]
		
		if set(groups).difference(self.valid_groups):
			raise Exception("One of the passed groups does not exist in the source tree")
		
		self._groups = groups
		return groups

	def load_from_file(self):
		"""Load groups from the configuration groups file
		This will complain if one of the groups specified in the file doesn't
		exist in the source tree (meaning it's considered an 'invalid group'"""
		if not os.path.exists(self.group_file): return

		with open(self.group_file, 'r') as f:
			try:
				self.groups = f.read().splitlines()
			except:
				raise Exception("Unable to load groups from configuration file")

	def save_to_file(self):
		"""This will save the currently defined list of groups for this configuration
		into the groups file"""
		with open(self.group_file, 'w+') as f:
			f.write('\n'.join(self.groups))

	def files(self):
		"""Get all configuration file objects that are to be installed"""
		files_set = set()

		for group in self.groups:
			for root,_, files in os.walk(group):
				# Trim the group name from the directory path
				root = root[len(group) + 1:]

				for file in files:
					# Remove the override extension. This will is going to be
					# installed without this extension, ConfigFile.real_paths
					# will handle locating this file
					if file.endswith(OVERRIDE_EXT):
						file = file[:-len(OVERRIDE_EXT)]

					files_set.add(os.path.join(root, file))

		# Get files as ConfigFile objects
		files = [ConfigFile(file, self) for file in files_set]

		# Don't include named_fragment files
		return [f for f in files if not f.is_named_fragment()]

	def install_tree(self, to=None):
		"""Install the configuration tree into a specific directory"""
		if not to: to = INSTALL_DIR

		# Install all files to the location
		[f.install(to) for f in self.files()]

	def diff_installed(self):
		"""Run a diff against the currently installed tree. This uses git as an
		external command to do the diffing"""
		temp_dir = tempfile.mkdtemp()
		self.install_tree(temp_dir)

		subprocess.call(GIT_DIFF + [INSTALL_DIR, temp_dir])

		shutil.rmtree(temp_dir)


class ConfigFile(object):

	@staticmethod
	def trim_file_whitespace(file_lines):
		"""Remove whiteface elements from the beginning and ends of a list"""
		for iterator in [enumerate(file_lines), reversed(list(enumerate(file_lines)))]:
			for i, line in iterator:
				if line.isspace():
					file_lines[i] = None
				else: break

		# Trim front and back empty lines
		return filter(None, file_lines)

	@staticmethod
	def strip_shebang(file_lines):
		"""Removes the shebang from the first line of a list"""
		if file_lines[0].startswith("#!/"):
			del file_lines[0]
			file_lines = ConfigFile.trim_file_whitespace(file_lines)

		return file_lines

	def __init__(self, relative_path, config):
		self.path = relative_path
		self.config = config
		self.compiled = None

	def name(self):
		"""Get the name of the file"""
		return os.path.basename(self.path)

	def directory(self):
		"""Get the directory the file is located in"""
		return os.path.dirname(self.path)

	def real_paths(self):
		"""Get the real paths of the source file"""
		paths = [os.path.join(SOURCE_DIR, group, self.path) for group in self.config.groups]

		# Check for overriding files and remove previous paths accordingly
		# We must iterate in reverse since the paths list starts at the file in
		# the lowest priority group
		for i, path in reversed(list(enumerate(paths))):
			# Skip if there is no overriding file in this group
			if not os.path.exists(path + OVERRIDE_EXT): continue

			# Use the overriding file and ignore all previous paths
			paths[i] = path + OVERRIDE_EXT
			paths = paths[i:]

		return [p for p in paths if os.path.exists(p)]

	def mode(self):
		"""Determine the mode of this file. If the file has multiple overriding
		files that don't have matching permissions, then the highest mode will
		be used"""
		return max([os.stat(p).st_mode for p in self.real_paths()])

	def named_append_points(self):
		""" Get a list of named append points in this file that will
		include fragments"""
		append_points = set()

		for path in self.real_paths():
			with open(path, 'r') as file:
				for line in file:
					if line.startswith(AP_IDENTIFIER):
						append_points.add(line[len(AP_IDENTIFIER):-1])

		return filter(None, append_points)

	def is_named_fragment(self):
		"""Check if this configuration file is actually a named fragment for
		another file"""
		match = re.match('^(.+)\.(.+)$', self.name())

		if not match:
			return False

		# Get the target configuration file
		target_path = os.path.join(self.directory(), match.group(1))
		target_file = ConfigFile(target_path, self.config)

		# The named append point to look for
		ap_name = match.group(2);

		# Check if the target file has the append point
		return match.group(2) in target_file.named_append_points()

	def compile(self):
		"""Compile this configuration file. This will take each file from the
		group and merge it based on these rules:

		 1. Files will be merged down from lowest priority groups (specified
		    first) to highest priority (specified last)

		 2. If the file being merged into includes an explicit append point it
		    will be merged at that location. Else it will just be appended to
			the end of the file being merged into.

		 3. If the file has named append points then we will look for a fragment
		    file that matches the append point name, if we can find it it will be
		    merged in."""
		self.compiled = None
		compiling_files = []

		# Read all file paths into arrays
		# This may be memory inefficient and may have to be changed later
		for path in self.real_paths():
			with open(path, 'r') as file:
				contents = file.readlines()

				# Replace front and back empty lines with None
				contents = self.trim_file_whitespace(contents)

				# Ensure a trailing newline
				if contents and not contents[-1].endswith('\n'):
					contents[-1] += '\n'

				# Ensure the file only has one explicit default append point
				if contents.count(AP_IDENTIFIER + '\n') > 1:
					raise Exception("More than one explicit append point in {0}".format(path))

				compiling_files.append(contents)

		# Nothing left to do if there were no files
		if not compiling_files:
			self.compiled_file = ""
			return self

		compiled = compiling_files[0];

		# Handle merging the file_data into one file. This will look for default
		# Append points, but if it can't find any will default to appending the file
		for single_file in compiling_files[1:]:
			# Remove shebang from first line
			single_file = self.strip_shebang(single_file)

			# Check if we need to slice into the array to insert
			try:
				slice_at = compiled.index(AP_IDENTIFIER + '\n')
				del compiled[slice_at]
				compiled[slice_at:1] = single_file
			except:
				compiled += ['\n'] + single_file

		# Handle merging in the named append points
		for name in self.named_append_points():
			appending_file = ConfigFile(self.path + '.' + name, self.config)
			appending_data = appending_file.compile().compiled

			# Replace all instances of this named append point
			while True:
				try:
					slice_at = compiled.index(AP_IDENTIFIER + name + '\n')
				except:
					break

				del compiled[slice_at]
				compiled[slice_at:1] = appending_data

		# Remove unused append point identifiers
		compiled = [l for l in compiled if not l.startswith(AP_IDENTIFIER)]

		# Keep the compiled lines for saving to a file later
		self.compiled = compiled

		return self

	def diff(self, against=INSTALL_DIR):
		"""Display a diff of the compiled file contest against the currently
		installed version of this file. This uses git as an external command to
		do the diffing"""
		if not self.compiled: self.compile()

		# Create a named temporary file to allow git to diff
		with tempfile.NamedTemporaryFile() as file:
			for line in self.compiled:
				file.write(line)
			file.flush()

			subprocess.call(GIT_DIFF + [os.path.join(against, self.path), file.name])

	def install(self, to):
		"""Install this file to a location"""
		if not self.compiled: self.compile()

		# Ensure directory exists for file
		path = os.path.join(to, self.path)
		try:
			os.makedirs(os.path.dirname(path))
		except:
			pass

		# Write the file
		with open(path, 'wb') as file:
			for line in self.compiled:
				file.write(line)

		# Set the file's mode
		os.chmod(path, self.mode())

# Setup the argument parser
parser = argparse.ArgumentParser(add_help=False)

# Handle getting the configuration path
parser.add_argument('-c', '--config', default=Configuration.default_group_file)

# Setup the sub-commands
sub_commands = parser.add_subparsers(dest='command')

# The help command
groups  = sub_commands.add_parser('groups',  add_help=False)
diff    = sub_commands.add_parser('diff',    add_help=False)
install = sub_commands.add_parser('install', add_help=False)
helps   = sub_commands.add_parser('help',    add_help=False)

# Groups sub commands
groups_commands = groups.add_subparsers(dest='group_command')

groups_available = groups_commands.add_parser('available', add_help=False)
groups_current   = groups_commands.add_parser('current',   add_help=False)
groups_set       = groups_commands.add_parser('set',       add_help=False)

# Groups-set options
groups_set.add_argument('groups', nargs='+')

# Diff options
diff.add_argument('files', nargs='*')

# Install options
install.add_argument('-l', '--location')
install.add_argument('-i', '--confirm')
install.add_argument('files', nargs='*')

# Parse arguments!
args = parser.parse_args()

config = Configuration(group_file=args.config)

if args.command == 'groups':
	pass

elif args.command == 'diff':
	pass

elif args.command == 'install':
	pass

if args.command == 'help':
	print USAGE
