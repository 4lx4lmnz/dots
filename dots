#!/bin/env python2.7

import sys, os
import glob
import re
import tempfile

# Locate the configuration directory that all source configuration files are
# stored in. This _should_ be the same directory that this script is located in
SOURCE_DIR = os.path.dirname(os.path.realpath(__file__))

# Put us in the source directory for convenience
os.chdir(SOURCE_DIR)

# Get the location that we will be installing all of the files into
INSTALL_DIR = os.getenv('XDG_CONFIG_HOME', os.path.join(os.environ['HOME'], '/.config'))

# The named append point identifier in files
AP_IDENTIFIER = '!!@@'

# The command to use to diff with git
GIT_DIFF = 'git diff --diff-filter=MA -- {path1} {path2}'

class Configuration(object):

	# This is a list of groups that are only a single directory deep and do not
	# contain any groups in sub-directories. The directories in these folders
	# will be the directories that are installed as configuration files
	single_directory_groups = ['base'];

	# Determine which groups are valid by looking at the directory structure of
	# that the script is installed in. Groups not defined in the
	# single_directory_groups array will be considered nested groups
	valid_groups = [g for g in glob.glob('*/*') if not
			g.startswith(tuple(single_directory_groups))] + \
			single_directory_groups

	# This is the default groups file that the configuration group listing for
	# the machine should be stored in
	default_group_file = os.path.join(os.getenv('XDG_CACHE_HOME',
		os.path.join(os.environ['HOME'], '.cache')), 'config-group')

	def __init__(self, group_file=default_group_file, groups=[]):
		self.group_file = group_file
		self.groups = groups

	@property
	def groups(self):
		"""Return the list of groups configured for this system"""
		return self._groups

	@groups.setter
	def groups(self, groups):
		"""Set the list of groups for this configuration"""
		# Trim trailing and leading slashes
		groups = [ x.strip('/') for x in groups]
		
		if set(groups).difference(self.valid_groups):
			raise Exception("One of the passed groups does not exist in the source tree")
		
		self._groups = groups
		return groups

	def load_from_file(self):
		"""Load groups from the configuration groups file
		This will complain if one of the groups specified in the file doesn't
		exist in the source tree (meaning it's considered an 'invalid group'"""
		with open(self.group_file, 'a') as f:
			try:
				self.groups = f.readlines()
			except:
				raise Exception("The loaded config file contains invalid groups")

	def save_to_file(self):
		"""This will save the currently defined list of groups for this configuration
		into the groups file"""
		with open(self.group_file, 'w+') as f:
			f.write('\n'.join(self.groups))

	def files(self):
		"""Get a list of all files that will be installed for this particular
		configuration. The paths are relative and will not include group names"""
		files_set = set()

		for group in self.groups:
			for root,_, files in os.walk(group):
				root  = root[len(group) + 1:]
				files = [os.path.join(root, file) for file in files]

				[files_set.add(path) for path in files]

		# Get files as ConfigFile objects
		files = [ConfigFile(file, self) for file in files_set]

		# Don't include named_fragment files
		return [f for f in files if not f.is_named_fragment()]

class ConfigFile(object):

	@staticmethod
	def trim_file_whitespace(file_lines):
		"""Remove whiteface elements from the beginning and ends of a list"""
		for iterator in [enumerate(file_lines), reversed(list(enumerate(file_lines)))]:
			for i, line in iterator:
				if line.isspace():
					file_lines[i] = None
				else: break

		# Trim front and back empty lines
		return filter(None, file_lines)

	@staticmethod
	def strip_shebang(file_lines):
		"""Removes the shebang from the first line of a list"""
		if file_lines[0].startswith("#!/"):
			del file_lines[0]
			file_lines = ConfigFile.trim_file_whitespace(file_lines)

		return file_lines

	def __init__(self, relative_path, config):
		self.path = relative_path
		self.config = config
		self.compiled = None

	def name(self):
		"""Get the name of the file"""
		return os.path.basename(self.path)

	def directory(self):
		"""Get the directory the file is located in"""
		return os.path.dirname(self.path)

	def real_paths(self):
		"""Get the real path of the source file"""
		paths = [os.path.join(SOURCE_DIR, group, self.path) for group in self.config.groups]
		return [p for p in paths if os.path.exists(p)]

	def mode(self):
		"""Determine the mode of this file. If the file has multiple overriding
		files that don't have matching permissions, then the highest mode will
		be used"""
		return max([os.stat(p).st_mode for p in self.real_paths()])

	def named_append_points(self):
		""" Get a list of named append points in this file that will
		include fragments"""
		append_points = set()

		for path in self.real_paths():
			with open(path, 'r') as file:
				for line in file:
					if line.startswith(AP_IDENTIFIER):
						append_points.add(line[len(AP_IDENTIFIER):-1])

		return filter(None, append_points)

	def is_named_fragment(self):
		"""Check if this configuration file is actually a named fragment for
		another file"""
		match = re.match('^(.+)\.(.+)$', self.name())

		if not match:
			return False

		# Get the target configuration file
		target_path = os.path.join(self.directory(), match.group(1))
		target_file = ConfigFile(target_path, self.config)

		# The named append point to look for
		ap_name = match.group(2);

		# Check if the target file has the append point
		return match.group(2) in target_file.named_append_points()

	def compile(self):
		"""Compile this configuration file. This will take each file from the
		group and merge it based on these rules:

		 1. Files will be merged down from top to bottom.

		 2. If the file being merged into includes an explicit append point it
		    will be merged at that location. Else it will just be appended to
			the end of the file being merged into.

		 3. If the file has named append points then we will look for a fragment
		    file that matches the append point name, if we can find it it will be
		    merged in.
		"""
		self.compiled = None
		compiling_files = []

		# Read all file paths into arrays
		# This may be memory inefficient and may have to be changed later
		for path in self.real_paths():
			with open(path, 'r') as file:
				contents = file.readlines()

				# Replace front and back empty lines with None
				contents = self.trim_file_whitespace(contents)

				# Ensure a trailing newline
				if not contents[-1].endswith('\n'):
					contents[-1] += '\n'

				# Ensure the file only has one explicit default append point
				if contents.count(AP_IDENTIFIER + '\n') > 1:
					raise Exception("More than one explicit append point in {0}".format(path))

				compiling_files.append(contents)

		# Nothing left to do if there were no files
		if not compiling_files:
			self.compiled_file = ""
			return self

		compiled = compiling_files[0];

		# Handle merging the file_data into one file. This will look for default
		# Append points, but if it can't find any will default to appending the file
		for single_file in compiling_files[1:]:
			# Remove shebang from first line
			single_file = self.strip_shebang(single_file)

			# Check if we need to slice into the array to insert
			try:
				slice_at = compiled.index(AP_IDENTIFIER + '\n')
				del compiled[slice_at]
				compiled[slice_at:1] = single_file
			except:
				compiled += ['\n'] + single_file

		# Handle merging in the named append points
		for name in self.named_append_points():
			appending_file = ConfigFile(self.path + '.' + name, self.config)
			appending_data = appending_file.compile().compiled

			# Replace all instances of this named append point
			while True:
				try:
					slice_at = compiled.index(AP_IDENTIFIER + name + '\n')
				except:
					break

				del compiled[slice_at]
				compiled[slice_at:1] = appending_data

		# Remove unused append point identifiers
		compiled = [l for l in compiled if not l.startswith(AP_IDENTIFIER)]

		# Keep the compiled lines for saving to a file later
		self.compiled = compiled

		return self

	def diff(self, against=INSTALL_DIR):
		"""Display a diff of the compiled file contest against the currently
		installed version of this file. This uses git as an external command to
		do the diffing"""
		if not self.compiled: self.compile()

		# Create a named temporary file to allow git to diff
		with tempfile.NamedTemporaryFile() as file:
			for line in self.compiled:
				file.write(line)
			file.flush()

			os.system(GIT_DIFF.format(path1=os.path.join(against, self.path), path2=file.name))
