#!/bin/env python2.7

import sys, os
import glob
import re

# Locate the configuration directory that all source configuration files are
# stored in. This _should_ be the same directory that this script is located in
SOURCE_DIR = os.path.dirname(os.path.realpath(__file__))

# Put us in the source directory for convenience
os.chdir(SOURCE_DIR)

# Get the location that we will be installing all of the files into
INSTALL_DIR = os.getenv('XDG_CONFIG_HOME', os.path.join(os.environ['HOME'], '/.config'))

# The named append point identifier in files
AP_IDENTIFIER = '!!@@'


class Configuration(object):

	# This is a list of groups that are only a single directory deep and do not
	# contain any groups in sub-directories. The directories in these folders
	# will be the directories that are installed as configuration files
	single_directory_groups = ['base'];

	# Determine which groups are valid by looking at the directory structure of
	# that the script is installed in. Groups not defined in the
	# single_directory_groups array will be considered nested groups
	valid_groups = [g for g in glob.glob('*/*') if not
			g.startswith(tuple(single_directory_groups))] + \
			single_directory_groups

	# This is the default groups file that the configuration group listing for
	# the machine should be stored in
	default_group_file = os.path.join(os.getenv('XDG_CACHE_HOME',
		os.path.join(os.environ['HOME'], '.cache')), 'config-group')

	def __init__(self, group_file=default_group_file, groups=[]):
		self.group_file = group_file
		self.groups = groups

	# Return the list of groups configured for this system
	@property
	def groups(self):
		return self._groups

	# Set the list of groups for this configuration
	@groups.setter
	def groups(self, groups):
		# Trim trailing and leading slashes
		groups = [ x.strip('/') for x in groups]
		
		if set(groups).difference(self.valid_groups):
			raise Exception("One of the passed groups does not exist in the source tree")
		
		self._groups = groups
		return groups

	# Load groups from the configuration groups file
	# This will complain if one of the groups specified in the file doesn't
	# exist in the source tree (meaning it's considered an 'invalid group'
	def load_from_file(self):
		with open(self.group_file, 'a') as f:
			try:
				self.groups = f.readlines()
			except:
				raise Exception("The loaded config file contains invalid groups")

	# This will save the currently defined list of groups for this configuration
	# into the groups file
	def save_to_file(self):
		with open(self.group_file, 'w+') as f:
			f.write('\n'.join(self.groups))

	# Get a list of all files that will be installed for this particular
	# configuration. The paths are relative and will not include group names
	def files(self):
		files_set = set()

		for group in self.groups:
			for root,_, files in os.walk(group):
				root  = root[len(group) + 1:]
				files = [os.path.join(root, file) for file in files]

				[files_set.add(path) for path in files]

		# Get files as ConfigFile objects
		files = [ConfigFile(file, self) for file in files_set]

		# Don't inclde named_fragment files
		return [f for f in files if not f.is_named_fragment()]




class ConfigFile(object):

	def __init__(self, relative_path, config):
		self.path = relative_path
		self.config = config
		self.mmaped_file = None

	def name(self):
		return os.path.basename(self.path)

	def directory(self):
		return os.path.dirname(self.path)

	def real_paths(self):
		paths = [os.path.join(SOURCE_DIR, group, self.path) for group in self.config.groups]
		return [p for p in paths if os.path.exists(p)]

	def install_path(self):
		return os.path.join(INSTALL_DIR, self.path)

	def named_append_points(self):
		append_points = set()

		for path in self.real_paths():
			with open(path, 'r') as file:
				for line in file:
					if line.startswith(AP_IDENTIFIER):
						append_points.add(line[len(AP_IDENTIFIER):-1])

		return filter(None, append_points)

	def is_named_fragment(self):
		match = re.match('^(.+)\.(.+)$', self.name())

		if not match:
			return False

		# Get the target configuration file
		target_path = os.path.join(self.directory(), match.group(1))
		target_file = ConfigFile(target_path, self.config)

		# The named append point to look for
		ap_name = match.group(2);

		# Check if the target file has the append point
		return match.group(2) in target_file.named_append_points()

	def compile(self):
		self.compiled_file = None
		file_data = []

		# Read all file paths into arrays
		# This may be memory inefficient and may have to be changed later
		for path in self.real_paths():
			with open(path, 'r') as file:
				contents = file.readlines()

				# Replace front and back empty lines with None
				for iterator in [enumerate(contents), reversed(list(enumerate(contents)))]:
					for i, line in iterator:
						if line.isspace():
							contents[i] = None
						else: break

				# Trim front and back empty lines
				contents = filter(None, contents)

				# Ensure a trailing newline
				if not contents[-1].endswith('\n'):
					contents[-1] += '\n'

				file_data.append(contents)
